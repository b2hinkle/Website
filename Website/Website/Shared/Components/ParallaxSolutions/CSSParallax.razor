@*
    Issues with this solution: 
     - Clipping lags behind when middle click scrolling (on slow computers) and is basically unavoidable since raf logic isn't done at same time as browsers' scroll logic
     - The most ugly solution

    This component provides the ability to parallax by providing .ParallaxContainer and .ParallaxElement classes and data-parallaxspeed data attribute.
    Workflow:
     - .ParallaxElement: Actual element that will parallax
         - must be an immediate child of .ParallaxContainer
     - data-parallaxspeed: Data attribute placed on ParallaxElement to modify its scroll speed (it's a multiplier)
         - 1 is normal scroll speed
         - 0 is no scrolling
     - .ParallaxContainer: Determines the parallax positioning of its parallax elements. Any parallax element should be at its original position when the container reaches the middle of the viewport.
*@
@inject IJSRuntime jsRuntime;
<div id="ParallaxWrapper">  @* Wrapper the size of the viewport *@
    <div id="PageContent">  @* 2nd wrapper to allow for dynamic height *@
        @ChildContent
    </div>
</div>

    


@code 
{
    [Parameter]
        public RenderFragment ChildContent { get; set; }

    private IJSObjectReference jsObjRef;    // js interactor
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            jsObjRef = await jsRuntime.InvokeAsync<IJSObjectReference>("import", "./Shared/Components/ParallaxSolutions/ParallaxWrapper.razor.js");

            await jsObjRef.InvokeVoidAsync("OnAfterRenderAsync");
        }
    }
}
